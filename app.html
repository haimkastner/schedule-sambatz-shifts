<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schedule App</title>
    <style>
        body {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        table {
            width: 60%;
            min-width: 60%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            padding: 10px;
            border: 1px solid black;
            text-align: center;
        }

        .name-list {
            width: 30%;
            margin-left: 20px;
        }

        .exclusion-form {
            margin-bottom: 20px;
        }

        .recalculate-button {
            margin-top: 20px;
            padding: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div>
        <h2>Random Schedule for Next <span id="daysAmount"></span> Days</h2>


        <!-- Recalculate Button -->
        <button class="recalculate-button" id="recalculateButton">Run</button>
        <button class="recalculate-button" id="stopButton">Stop</button>

        <!-- Table to display dates and names -->
        <table id="scheduleTable">
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Morning</th>
                    <th>Evening</th>
                    <th>Night</th>
                    <th>Day Off</th>
                </tr>
            </thead>
            <tbody>
                <!-- Rows will be generated by JavaScript -->
            </tbody>
        </table>

        <h4>Iteration <span id="iterationCounter">0</span> Score <span id="solutionScore">0</span></h4>
    </div>

    <!-- Display list of names -->
    <div class="name-list">
        <h3>Sambat"z:</h3>
        <ul id="nameList">
            <!-- List items will be generated by JavaScript -->
        </ul>

        <!-- Display exclusions -->
        <h3>Restrictions:</h3>
        <ul id="exclusionList">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>

        <h3>Requests:</h3>
        <ul id="requestsList">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>

    </div>
    <div>
        <h3>Statistics:</h3>
        <ul id="closedOffShiftList">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>
        <span>Desired Shifts:</span>
        <ul id="desireShifts">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>
        <span>Undesired Shifts:</span>
        <ul id="undesiredShifts">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>
        Consecutive Days Off:
        <ul id="consecutiveList">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>
        Shift Closed to Days Off:
        <ul id="closeToDayOffList">
            <!-- Exclusion items will be generated by JavaScript -->
        </ul>

    </div>

    <script>
        const nextDays = 7;

        // Array of names to be randomly assigned
        const names = ['Haim', 'Nicolas', 'Elad', 'Avia', 'Danit', 'Ayala', 'Aviad', 'Ami'];

        function formatDate(date) {
            const day = String(date.getDate()).padStart(2, '0'); // Get day and pad with zero if needed
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Get month (0-based) and pad
            const year = date.getFullYear(); // Get full year

            return `${day}/${month}/${year}`; // Format as DD/MM/YYYY
        }

        // Object to store exclusions (name and their corresponding excluded dates) name:Date day format
        const exclusions = {
            'Haim': [formatDate(new Date('2024-10-23')), formatDate(new Date('2024-10-24'))],
            'Avia': [formatDate(new Date('2024-10-23')), formatDate(new Date('2024-10-24'))],
            'Nicolas': [formatDate(new Date('2024-10-27'))],
            'Ayala': [formatDate(new Date('2024-10-28'))],
            'Aviad': [formatDate(new Date('2024-10-29'))],
        };

        const desiredShifts = {
            // 'Ayala': ['nightNames'],
            'Danit': ['morningNames', 'eveningNames'],
        };

        const namesInShift = {
            morningNames: 2,
            eveningNames: 2,
            nightNames: 1,
        }

        let iterationCount = 0;

        // Object to store the shift count for each name
        let globalShiftCount = {};
        let globalDayOffCount = {};
        let globalEndCloseCount = {};
        let globalDayInterruptCount = {};

        let iterationIndex = 0;
        const maxIterations = 10000000;
        const keepSolutions = 15;
        // score,solution.
        let solutions = [];

        function countUndesiredShifts(shifts) {
            // Create a results object to store counts for each person
            const result = {};

            // Initialize counts for each name in the desiredShifts
            for (const name in desiredShifts) {
                result[name] = 0;
            }

            // All possible shift types
            const allShiftTypes = ['morningNames', 'eveningNames', 'nightNames'];

            // Iterate through the shifts and check for each undesired shift
            shifts.forEach(shift => {
                for (const name in desiredShifts) {
                    const desiredShiftTypes = desiredShifts[name];

                    // Find the shift types that are not in the desiredShiftTypes
                    const undesiredShiftTypes = allShiftTypes.filter(shiftType => !desiredShiftTypes.includes(shiftType));

                    // Count how many times the person is in an undesired shift
                    undesiredShiftTypes.forEach(shiftType => {
                        if (shift[shiftType].includes(name)) {
                            result[name]++;
                        }
                    });
                }
            });

            return result;
        }

        function countDesiredShifts(shifts) {
            // Create a results object to store counts for each person
            const result = {};

            // Initialize counts for each name in the desiredShifts
            for (const name of names) {
                result[name] = 0;
            }

            // Iterate through the shifts and check for each desired shift
            shifts.forEach(shift => {
                for (const name in desiredShifts) {
                    const desiredShiftTypes = desiredShifts[name];

                    desiredShiftTypes.forEach(shiftType => {
                        if (shift[shiftType].includes(name)) {
                            result[name]++;
                        }
                    });
                }
            });

            return result;
        }

        function analyzeShiftsWithScore(shifts) {
            // Create sets to store the names of everyone in the shifts
            const allNames = new Set();
            shifts.forEach(shift => {
                shift.morningNames.forEach(name => allNames.add(name));
                shift.eveningNames.forEach(name => allNames.add(name));
                shift.nightNames.forEach(name => allNames.add(name));
            });

            // Create objects to store results
            const consecutiveDaysOff = {};

            allNames.forEach(name => {
                consecutiveDaysOff[name] = 0;
            });

            // Function to calculate the consecutive days off with score
            allNames.forEach(name => {
                let daysOff = 0;

                shifts.forEach((day, index) => {
                    const hasShiftToday = day.morningNames.includes(name) || day.eveningNames.includes(name) || day.nightNames.includes(name);

                    // Count consecutive days off with increasing score
                    if (!hasShiftToday) {
                        daysOff++;
                    } else {
                        if (daysOff > 0) {
                            consecutiveDaysOff[name] += Math.pow(2, daysOff); // Apply the score based on consecutive days off
                            daysOff = 0; // Reset the counter
                        }
                    }
                });

                // Check if they had days off at the end of the array
                if (daysOff > 0) {
                    consecutiveDaysOff[name] += Math.pow(2, daysOff); // Apply the score for the last set of days off
                }
            });

            return {
                consecutiveDaysOff
            };
        }

        function calculateMaxDaysOff(shifts) {
            // Create sets to store the names of everyone in the shifts
            const allNames = new Set();
            shifts.forEach(shift => {
                shift.morningNames.forEach(name => allNames.add(name));
                shift.eveningNames.forEach(name => allNames.add(name));
                shift.nightNames.forEach(name => allNames.add(name));
            });

            // Create objects to store results
            const maxConsecutiveDaysOff = {};

            // Initialize max consecutive days off for each name
            allNames.forEach(name => {
                maxConsecutiveDaysOff[name] = 0;
            });

            // Iterate over all names to calculate max consecutive days off
            allNames.forEach(name => {
                let currentStreak = 0;
                let maxStreak = 0;

                // Loop through each shift day
                shifts.forEach(shift => {
                    const hasShiftToday = shift.morningNames.includes(name) || shift.eveningNames.includes(name) || shift.nightNames.includes(name);

                    // If the person doesn't have a shift, increase the streak
                    if (!hasShiftToday) {
                        currentStreak++;
                    } else {
                        // If they do have a shift, update the max streak and reset the current streak
                        if (currentStreak > maxStreak) {
                            maxStreak = currentStreak;
                        }
                        currentStreak = 0;
                    }
                });

                // Handle the case where the last streak continues until the end of the shifts array
                if (currentStreak > maxStreak) {
                    maxStreak = currentStreak;
                }

                // Store the max streak in the result object
                maxConsecutiveDaysOff[name] = maxStreak;
            });

            return maxConsecutiveDaysOff;
        }

        function analyzeShifts(shifts) {
            // Create sets to store the names of everyone in the shifts
            const allNames = new Set();
            shifts.forEach(shift => {
                shift.morningNames.forEach(name => allNames.add(name));
                shift.eveningNames.forEach(name => allNames.add(name));
                shift.nightNames.forEach(name => allNames.add(name));
            });

            // Create objects to store results
            const consecutiveDaysOff = {};
            const afterDayOffMorning = {};
            const beforeDayOffEvening = {};
            const beforeDayOffNight = {};

            allNames.forEach(name => {
                consecutiveDaysOff[name] = 0;
                afterDayOffMorning[name] = 0;
                beforeDayOffEvening[name] = 0;
                beforeDayOffNight[name] = 0;
            });

            // Function to calculate the consecutive days off and day off patterns
            allNames.forEach(name => {
                let daysOff = 0;

                shifts.forEach((day, index) => {
                    const hasShiftToday = day.morningNames.includes(name) || day.eveningNames.includes(name) || day.nightNames.includes(name);

                    // Count consecutive days off
                    if (!hasShiftToday) {
                        daysOff++;
                    } else {
                        if (daysOff > 0) {
                            consecutiveDaysOff[name] += daysOff;
                            daysOff = 0; // Reset the counter
                        }
                    }

                    // Count morning shift after day off
                    if (index > 0) {
                        const previousDay = shifts[index - 1];
                        const hadDayOffYesterday = !previousDay.morningNames.includes(name) && !previousDay.eveningNames.includes(name) && !previousDay.nightNames.includes(name);
                        if (hadDayOffYesterday && day.morningNames.includes(name)) {
                            afterDayOffMorning[name]++;
                        }
                    }

                    // Count evening and night shifts before a day off
                    if (index < shifts.length - 1) {
                        const nextDay = shifts[index + 1];
                        const hasDayOffTomorrow = !nextDay.morningNames.includes(name) && !nextDay.eveningNames.includes(name) && !nextDay.nightNames.includes(name);

                        if (day.eveningNames.includes(name) && hasDayOffTomorrow) {
                            beforeDayOffEvening[name]++;
                        }

                        if (day.nightNames.includes(name) && hasDayOffTomorrow) {
                            beforeDayOffNight[name]++;
                        }
                    }
                });

                // Check if they had days off at the end of the array
                if (daysOff > 0) {
                    consecutiveDaysOff[name] += daysOff;
                }
            });

            return {
                consecutiveDaysOff,
                afterDayOffMorning,
                beforeDayOffEvening,
                beforeDayOffNight
            };
        }

        function calcSolutionScore(solutionsData, shiftCounts, offCounts) {
            const daysOffAnalyzeCount = analyzeShifts(solutionsData);
            const desiredShifts = countUndesiredShifts(solutionsData);
            const analyzeShiftsWithScoreRes = calculateMaxDaysOff(solutionsData);
            // return calculateShiftScore(analyzeShiftsWithScoreRes);

            return (calculateShiftScore(shiftCounts) * 70)
                + (calculateShiftScore(offCounts) * 50)
                + (calculateShiftScore(analyzeShiftsWithScoreRes) * 50)
                + (calculateShiftScore(desiredShifts) / 15)
                + (calculateShiftScore(daysOffAnalyzeCount.afterDayOffMorning) / 10)
                + (calculateShiftScore(daysOffAnalyzeCount.beforeDayOffEvening) / 10)
                + (calculateShiftScore(daysOffAnalyzeCount.beforeDayOffNight) * 10)
                ;
        }

        function calculateShiftScore(shiftCounts) {

            // Step 1: Determine the ideal shift count (mean in this case)
            const shiftValues = Object.values(shiftCounts);

            if (shiftValues.length < names.length) {
                return 1000;
            }

            if (shiftValues.some(c => c === 0)) {
                return 1000;
            }
            const idealCount = shiftValues.reduce((acc, count) => acc + count, 0) / shiftValues.length;

            // Step 2: Calculate the differences
            const differences = {};
            for (const name in shiftCounts) {
                differences[name] = Math.abs(shiftCounts[name] - idealCount);
            }

            // Step 3: Compute the score
            const score = Object.values(differences).reduce((acc, diff) => acc + diff, 0);

            return score;
        }


        // Function to get a random name from the array, excluding specific names
        function getRandomName(exclude = []) {
            const filteredNames = names.filter(name => !exclude.includes(name));
            return filteredNames[Math.floor(Math.random() * filteredNames.length)];
        }

        // Function to get the date for the next N days
        function getUpcomingDates(numDays) {
            const today = new Date();
            const dates = [];

            for (let i = 0; i < numDays; i++) {
                const nextDate = new Date();
                nextDate.setDate(today.getDate() + i); // Set the date to upcoming day
                dates.push(nextDate); // Push the date as a string in the format "MM/DD/YYYY"
            }

            return dates;
        }

        // Function to fill the table with random names based on the new shift requirements
        function fillTable() {

            const upcomingDates = getUpcomingDates(nextDays); // Get next 10 days

            const shiftCount = {};
            const offCount = {};
            const endCloseCount = {};
            const dayInterruptCount = {};

            const solution = [];

            const solutionsData = [];
            let previousNight = [];

            upcomingDates.forEach(date => {

                const dayWorkCount = {};
                const solutionDayData = {};

                // Create a cell for the date
                const dateCell = document.createElement('td');
                dateCell.textContent = formatDate(date);

                // Assign names for morning shift (2 names)
                const morningNames = [];
                for (let i = 0; i < namesInShift.morningNames; i++) {
                    const name = getRandomName([...morningNames, ...previousNight, ...getExcludedNames(date)]);
                    morningNames.push(name);
                    shiftCount[name] = (shiftCount[name] || 0) + 1; // Increment shift count for the name
                    dayWorkCount[name] = true;
                }
                solutionDayData.morningNames = morningNames;

                // Assign names for evening shift (2 names)
                const eveningNames = [];
                for (let i = 0; i < namesInShift.eveningNames; i++) {
                    const name = getRandomName([...eveningNames, ...morningNames, ...getExcludedNames(date)]);
                    eveningNames.push(name);
                    shiftCount[name] = (shiftCount[name] || 0) + 1; // Increment shift count for the name
                    dayWorkCount[name] = true;
                }
                solutionDayData.eveningNames = eveningNames;


                ////

                const nightNames = [];
                for (let i = 0; i < namesInShift.nightNames; i++) {
                    const name = getRandomName([...eveningNames, ...nightNames, ...getExcludedNames(date)]);
                    nightNames.push(name);
                    shiftCount[name] = (shiftCount[name] || 0) + 1; // Increment shift count for the name
                    dayWorkCount[name] = true;
                }
                solutionDayData.nightNames = nightNames;
                previousNight = nightNames;

                // Create cells for the shifts
                const morningCell = document.createElement('td');
                morningCell.textContent = morningNames.join(', '); // Join the names for display

                const eveningCell = document.createElement('td');
                eveningCell.textContent = eveningNames.join(', '); // Join the names for display

                const nightCell = document.createElement('td');
                nightCell.textContent = nightNames.join(', '); // Join the names for display



                const offNames = [];
                for (const name of names) {
                    if (!dayWorkCount[name]) {
                        offCount[name] = (offCount[name] || 0) + 1; // Increment shift count for the name
                        offNames.push(name);
                    }
                }

                const offCell = document.createElement('td');
                offCell.textContent = offNames.join(', ')
                solutionsData.push(solutionDayData)
                solution.push({
                    dateCell,
                    morningCell,
                    eveningCell,
                    nightCell,
                    offCell
                });

            });

            iterationCount++;
            const iterationCounter = document.querySelector('#iterationCounter');
            iterationCounter.textContent = iterationCount.toLocaleString();

            const score = calcSolutionScore(solutionsData, shiftCount, offCount) || 100000;

            if (solutions.length && score > Math.min(...solutions.map(s => s.score))) {
                return;
            }

            globalShiftCount = shiftCount;
            globalDayOffCount = offCount;
            renderSolution(solution);
            const solutionScore = document.querySelector('#solutionScore');
            solutionScore.textContent = score.toLocaleString();

            const daysAmount = document.querySelector('#daysAmount');
            daysAmount.textContent = nextDays.toString();

            renderStatistics(solutionsData);
            solutions.push({
                solutionsData,
                solution,
                score,
            })

            // Sort solutions by score in ascending order
            solutions = solutions
                .sort((a, b) => a.score - b.score) // Sort by score
                .slice(0, 15); // Get the first 15 solutions

        }

        function renderStatistics(solution) {
            const calcDesiredShifts = countDesiredShifts(solution);
            const calcNotDesiredShifts = countUndesiredShifts(solution);
            const daysOffAnalyzeCount = analyzeShifts(solution);
            const maxDaysOff = calculateMaxDaysOff(solution);

            const desireElement = document.getElementById('desireShifts');
            desireElement.innerHTML = ''; // Clear the list before adding new items

            for (const [name, shifts] of Object.entries(calcDesiredShifts)) {
                if (!(name in desiredShifts)) {
                    continue;
                }
                const li = document.createElement('li');
                li.textContent = `${name}: ${shifts}`; // Display name and shift count
                desireElement.appendChild(li);
            }

            const undesiredShiftsElement = document.getElementById('undesiredShifts');
            undesiredShiftsElement.innerHTML = ''; // Clear the list before adding new items

            for (const [name, shifts] of Object.entries(calcNotDesiredShifts)) {
                if (!(name in desiredShifts)) {
                    continue;
                }
                const li = document.createElement('li');
                li.textContent = `${name}: ${shifts}`; // Display name and shift count
                undesiredShiftsElement.appendChild(li);
            }

            const consecutiveListElement = document.getElementById('consecutiveList');
            consecutiveListElement.innerHTML = ''; // Clear the list before adding new items

            for (const [name, shifts] of Object.entries(maxDaysOff)) {
                const li = document.createElement('li');
                li.textContent = `${name}: ${shifts}`; // Display name and shift count
                consecutiveListElement.appendChild(li);
            }

            const closeToDayOffListElement = document.getElementById('closeToDayOffList');
            closeToDayOffListElement.innerHTML = ''; // Clear the list before adding new items

            for (const name of names) {
                const li = document.createElement('li');
                const amount = daysOffAnalyzeCount.afterDayOffMorning[name] + daysOffAnalyzeCount.beforeDayOffEvening[name] + daysOffAnalyzeCount.beforeDayOffEvening[name];
                li.textContent = `${name}: ${amount || 0}`; // Display name and shift count
                closeToDayOffListElement.appendChild(li);
            }
        }

        function renderSolution(solution) {
            const tableBody = document.querySelector('#scheduleTable tbody');
            tableBody.innerHTML = ''; // Clear the previous table rows

            for (const {
                dateCell,
                morningCell,
                eveningCell,
                nightCell,
                offCell
            } of solution) {
                // Create a table row
                const row = document.createElement('tr');

                // Append the cells to the row
                row.appendChild(dateCell);
                row.appendChild(morningCell);
                row.appendChild(eveningCell);
                row.appendChild(nightCell);
                row.appendChild(offCell);

                // Append the row to the table body
                tableBody.appendChild(row);
            }

        }

        // Function to get excluded names for a specific date
        function getExcludedNames(date) {
            const formattedDate = formatDate(new Date(date));
            return Object.keys(exclusions)
                .filter(name => exclusions[name].includes(formattedDate));
        }

        // Function to display the list of names and their shift counts
        function displayNames() {
            const nameList = document.getElementById('nameList');
            nameList.innerHTML = ''; // Clear the list before adding new items

            names.forEach(name => {
                const li = document.createElement('li');
                li.textContent = `${name}: ${globalShiftCount[name] || 0} shifts ${globalDayOffCount[name] || 0} off days`; // Display name and shift count
                nameList.appendChild(li);
            });
        }

        // Function to display the exclusions
        function displayExclusions() {
            const exclusionList = document.getElementById('exclusionList');
            exclusionList.innerHTML = ''; // Clear the list before adding new items

            for (const name in exclusions) {
                const li = document.createElement('li');
                li.textContent = `${name}: ${exclusions[name].join(', ')}`; // Display name and their excluded dates
                exclusionList.appendChild(li);
            }
        }

        function displayDesiredShifts() {
            const requestsList = document.getElementById('requestsList');
            requestsList.innerHTML = ''; // Clear the list before adding new items

            for (const name in desiredShifts) {
                const li = document.createElement('li');
                li.textContent = `${name}: ${desiredShifts[name].map(s => s.split('Names')[0]).join(', ')}`; // Display name and their excluded dates
                requestsList.appendChild(li);
            }
        }

        // Function to add an exclusion for a name
        function addExclusion() {
            const name = document.getElementById('exclusionName').value.trim();
            const date = document.getElementById('exclusionDate').value;

            if (name && date) {
                if (!exclusions[name]) {
                    exclusions[name] = [];
                }
                exclusions[name].push(new Date(date).toLocaleDateString());
                document.getElementById('exclusionName').value = ''; // Clear input
                document.getElementById('exclusionDate').value = ''; // Clear input
                alert(`Exclusion added: ${name} cannot work on ${date}`);
                displayExclusions(); // Update the UI to show the new exclusions
            } else {
                alert('Please provide a valid name and date.');
            }
        }

        // Function to recalculate the shifts
        function recalculate() {
            fillTable(); // Refill the table with new random assignments
            displayNames(); // Update the names list
            displayExclusions(); // Update the exclusions list
        }

        let stopFlag = true;;

        function mutation() {
            iterationIndex++;

            if (iterationIndex > maxIterations || stopFlag) {
                intervalHandler = undefined;
                return;
            }

            recalculate();
            intervalHandler = setInterval(mutation, 10);
        }

        function runGens() {
            iterationIndex = 0;
            stopFlag = false;
            mutation();
        }

        function stopMutations() {
            stopFlag = true;
            if (intervalHandler) {
                clearInterval(intervalHandler);
            }
        }

        // Event listener for recalculate button
        document.getElementById('recalculateButton').addEventListener('click', runGens);
        document.getElementById('stopButton').addEventListener('click', stopMutations);

        // Call the functions to populate the table and display the list of names when the page loads
        fillTable();
        displayNames();
        displayExclusions();
        displayDesiredShifts();



    </script>
</body>

</html>